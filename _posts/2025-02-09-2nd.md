---
layout: post
title: "[스나이퍼팩토리] 한컴AI아카데미 3주차 1일 - JS 배열"
date: 2025-02-09
categories: [한컴ai]
author: "yujinoh0103"
---

const로 배열을 만든 후 수정해도 문제가 안생기는 이유: 배열은 주소를 참조하기 때문에 주소가 바뀌지 않아서 문제가 생기지 않음.

```java script


```

## hoisting

1. var

스코프(Scope): var로 선언된 변수는 함수 레벨 스코프(function-level scope)를 가집니다. 즉, 함수 내에서 선언된 변수는 해당 함수 내에서만 유효하며, 함수 외부에서 선언된 변수는 전역 스코프(global scope)를 가집니다.
DEV-COCO.TISTORY.COM

재선언 및 재할당: 같은 스코프 내에서 var로 선언된 변수는 재선언과 재할당이 가능합니다.
FREECODECAMP.ORG

호이스팅(Hoisting): var로 선언된 변수는 선언이 해당 스코프의 최상단으로 끌어올려지며, 초기화는 원래 위치에서 이루어집니다. 따라서 선언 전에 변수를 참조하면 undefined가 반환됩니다.
DEV-COCO.TISTORY.COM

2. let

스코프(Scope): let으로 선언된 변수는 블록 레벨 스코프(block-level scope)를 가집니다. 즉, 중괄호 {}로 묶인 코드 블록 내에서만 유효합니다.
DEV-COCO.TISTORY.COM

재선언 및 재할당: 같은 스코프 내에서 let으로 선언된 변수는 재선언이 불가능하지만, 재할당은 가능합니다.
FREECODECAMP.ORG

호이스팅(Hoisting): let으로 선언된 변수도 호이스팅이 발생하지만, 초기화가 이루어지지 않으므로 선언 전에 변수를 참조하면 ReferenceError가 발생합니다.
DEV-COCO.TISTORY.COM

3. const

스코프(Scope): const로 선언된 변수는 let과 마찬가지로 블록 레벨 스코프를 가집니다.
DEV-COCO.TISTORY.COM

재선언 및 재할당: const로 선언된 변수는 재선언과 재할당이 모두 불가능합니다.
FREECODECAMP.ORG

호이스팅(Hoisting): const로 선언된 변수도 호이스팅이 발생하지만, 초기화가 이루어지지 않으므로 선언 전에 변수를 참조하면 ReferenceError가 발생합니다.
DEV-COCO.TISTORY.COM

호이스팅(Hoisting) 요약:

var: 선언이 스코프의 최상단으로 끌어올려지며, 초기화는 원래 위치에서 이루어집니다. 선언 전에 변수를 참조하면 undefined가 반환됩니다.

let과 const: 선언이 스코프의 최상단으로 끌어올려지지만, 초기화가 이루어지지 않으므로 선언 전에 변수를 참조하면 ReferenceError가 발생합니다.

권장 사항:

변수의 재할당이 필요 없는 경우 const를 사용하고, 재할당이 필요한 경우에만 let을 사용하는 것이 좋습니다.
CHEERSHENNAH.TISTORY.COM

var는 함수 레벨 스코프를 가지며, 호이스팅 시 초기화가 이루어지지 않아 예기치 않은 결과를 초래할 수 있으므로 사용을 지양하는 것이 좋습니다.
DEV-COCO.TISTORY.COM

이러한 특성을 이해하고 적절하게 사용하면 코드의 가독성과 유지보수성을 높일 수 있습니다.

## Symbol

각 symbol 값은 고유하고 변경 불가능하며, 충돌 없이 객체에 새로운 속성을 추가할 수 있음. 비공개 속성을 만들 수도..

```JS
let id =Symbol("id");
let user={
  name: "John";
  [id]:123,
};

console.log(user[id]); //123
console.log(user.id); //undefined
```

symbol은 . 표기법으로 접근이 불가능.

let id = Symbol("id");:
Symbol("id")는 고유한 값을 생성하는 Symbol 객체를 만듭니다. Symbol은 기본적으로 유일한 값이므로, 이 값은 다른 Symbol과 절대로 같을 수 없습니다.
"id"는 해당 심볼에 대한 설명을 나타내며, 디버깅에 유용하지만 실제 값과는 관계없습니다.
let user = { name: "John", [id]: 123 };:
객체 user를 생성하면서, name이라는 문자열 속성 외에 [id]: 123이 추가됩니다. 여기서 중요한 부분은 id가 심볼(Symbol) 이므로 [id]는 이 심볼 값을 키로 사용하여 속성을 정의하는 방식입니다.
id가 심볼이기 때문에 user 객체에는 name과 함께 심볼 id를 키로 하는 속성이 존재합니다. 이 속성의 값은 123입니다.
결과적으로 user 객체는 다음과 같이 구성됩니다:
javascript
복사
편집
{
name: "John",
[Symbol("id")]: 123
}
왜 [id] 인가?
대괄호 문법 ([id]): 이 문법은 동적 키를 생성하는 방법입니다. 객체 리터럴에서 대괄호 안에 변수를 넣으면, 그 변수의 값이 실제 속성 키로 사용됩니다.
여기서 id는 심볼이므로 [id]는 user 객체의 속성 이름으로 Symbol("id")라는 고유한 심볼 값을 사용하게 됩니다.
**심볼(Symbol)**을 객체의 속성 이름으로 사용하면, 그 속성은 다른 속성과 충돌할 수 없게 됩니다. 즉, 일반적인 문자열 키와 달리 심볼은 항상 고유한 값을 가지므로 충돌 없이 안전하게 사용할 수 있습니다.
결론:
\[id\]는 객체의 속성 키로 id 심볼을 동적으로 사용하며, 그 결과로 user 객체의 속성 이름은 심볼이 됩니다. 이는 속성 키를 고유하게 만들어 충돌을 방지할 수 있는 방법입니다.

## 반복문

`for ... of`문 : 배열/이터러블 객체의 모든 요소를 차례대로.

```JS
const fruits =["사과","바나나","오렌지"];
for (let fruit of fruits){
  console.log(fruit);
}
```

`for ... in`문: 객체의 모든 열거 가능한 속성 순회회

✅ Object와 함께 for...in 사용

for...in은 Object의 key를 순회.
아래 예시와 같이 사용하면 key를 순회하면서 value값도 함께 표시할 수 있다.

// for..in Input

const car = {
make: "🚘Tesla",
model: "Model 3",
year: 2020
};

for (const i in car) {
console.log(`${i}: ${car[i]}`);
// key값에 접근, value는 직접 접근 불가
}
// for..in Output

make: 🚘Tesla
model: Model 3
year: 2020

✅ Array와 함께 for…in 사용

for...in 은 Object를 순회할 때 key를 가져오는데 Array는 key가 없으므로 index를 가져온다.
array에서 반환되는 index 값은 number가 아닌 string이라는 점 주의.

// for..in Input

const fruits = ["🍎apple", "🍌banana", "🍊orange"];

for (const i in fruits) {
console.log(`${i}: ${fruits[i]}`);
}
// for..in Output

0: 🍎apple
1: 🍌banana
2: 🍊orange
출처: https://jaycode.tistory.com/24 [JAY⌨️CODE:티스토리]

## 배열의 일부분 조작 - splice()

배열의 특정 위치에서

## 새로운 배열을 반환 - slice(), concat(), map(), filter()

## 값의 위치 찾기 - lastIndexOf()

없으면 -1 반환

## 참조가 아닌 것

원시 데이터 타입인 경우 변수가 실제 데이터 값을 직접 저장해 원본 데이터에 영향을 주지 않음

## 얕은 복사

가장 최상위는.. 복사가 되는데 하위에 참조하는 다른 객체는 참조 값이.

Object.assign()

```JS

let car={
    brand:"toyota",

}

let carCopy1= Object.assigin({},car);
let carCoy2={...car};

carCopy1.
```

레퍼런스(참조)와 같음..?

## 깊은 복사 - JSON.parse(JSON.stringfy())

모든 중첩 객체를 포함하여 완전히 새로운 객체를 생성함.

## 객체 병합하기

얕은 복사로 병합됨
스프레드 연산자 ...나 Object.assign() 메서드를 사용해서 여러 객체를 하나로 병합.
같은 키가 있는 경우, 나중에 오는 객체의 값이 우선됨.

## Closure

내부 함수가 외부함수의 변수에 접근할 수 있는 구조.
데이터 은닉과 모듈화에 유용

```JS
function outFunction(x){
    return function(y){
        return x+y;
    };
}

outerFunction(7);
```

## 클로저의 활용

데이터 은닉

```JS

function alpha(x){
    const result = function(y) {
        return x()+y;
    };
    return result;
}
function beta(z){
    return z;
}
console.log(alpha(beta)(4));
```

# 코드 설명

이 코드는 자바스크립트에서 **고차 함수**(Higher-Order Function)를 사용한 예시입니다. 고차 함수는 다른 함수를 인자로 받거나, 함수를 반환하는 함수입니다.

## 코드 분석

```javascript
function alpha(x) {
  const result = function (y) {
    return x() + y;
  };
  return result;
}

function beta(z) {
  return z;
}

console.log(alpha(beta)(4));
```

### 1. `alpha` 함수:

- `alpha` 함수는 **고차 함수**입니다. `alpha`는 함수 `x`를 인자로 받아 **내부에서 또 다른 함수를 반환**합니다.
- 반환되는 함수는 인자로 `y`를 받으며, `x()`와 `y`를 더한 값을 반환합니다.

```javascript
function alpha(x) {
  const result = function (y) {
    return x() + y;
  };
  return result;
}
```

### 2. `beta` 함수:

- `beta` 함수는 단순한 함수로, 인자로 받은 값을 그대로 반환합니다.

```javascript
function beta(z) {
  return z;
}
```

### 3. `alpha(beta)(4)`:

- 먼저 `alpha(beta)`를 호출합니다. `alpha` 함수는 `beta`를 인자로 받습니다.
  - `x`는 `beta` 함수가 됩니다.
  - 내부에서 `result`라는 함수를 반환하는데, 이 함수는 인자 `y`를 받습니다. `result` 함수는 `x()`와 `y`를 더한 값을 반환합니다.
- 여기서 `x()`는 `beta()`를 의미하는데, `beta` 함수는 인자 없이 호출되므로 `beta()`는 `undefined`를 반환합니다.
- 이후 `alpha(beta)(4)`에서 `4`가 `y`로 전달됩니다.
  - 결과적으로 `undefined + 4`가 되어 **`NaN`**이 반환됩니다.

### 실행 흐름

1. `alpha(beta)` 실행 → `beta()` 함수 반환 (`undefined`)
2. `result(4)` 실행 → `undefined + 4 = NaN`
3. 최종적으로 `NaN`이 출력됩니다.

### 결론

이 코드는 고차 함수의 동작을 보여주지만, `beta()` 함수가 인자를 받지 않기 때문에 `undefined + y`의 연산으로 `NaN`을 출력합니다.

```JS
function createPerson(name){
    let _name=name; // private 변수

    return{
        getName: function(){
            return _name;
        },

        setName: function(newName){
            _name=newName;
        },
    };
}

const person=createPerson("Alice");

//console.log(person.getName()); "Alice"

console.log(person.name()); //undefined

```

getName을 통해 \_name을 알아내고,
이거를 return으로 내보내주지 않으면 아래에서 알 수가 없다.

## 함수 팩토리

함수를 만드는 함수.

- 코드 재사용성 향상
- 유연한..

```JS
function multiplyBy(factor){
    return function (number){

    }
}

```

## 비동기 프로그래밍

모든 코드는 위에서부터 순차적으로 실행되지만, 비동기는 나중에 처리되기 위해서 (다른 스레드로 빼두고) 그 다음 라인을 실행함.

```JS

function asyncOperation(callback){
    let data=0;
    setTimeout((=>{
        data=42;
        callback(data);
    }, 1000);
    return;)
}

```

## 즉시 실행함수수

```JS
const counter= (function(){
    let count=0;
    return{
        increment: function(){

        }
    }
})


## 객체 리터럴 반환

함수를 객체로 만들어서 리턴시켜 주면, 함수 안에

## 결론

스코프는 변수의 접근 범위를 정의하며, 클로저는 함수의 레벨을 넘어선 ..
```

## ... 의 의미

...(Spread, Rest Operator) 사용 이유
JavaScript에서 ... 연산자는 Spread Operator(전개 연산자) 및 Rest Parameter(나머지 매개변수) 두 가지 용도로 사용됩니다. 이 코드에서는 Rest Parameter(나머지 매개변수) 로 사용되었습니다.

1. 나머지 매개변수 (Rest Parameter)
   javascript
   코드 복사
   function sum(...numbers) {
   let total = 0;
   for (let num of numbers) {
   total += num;
   }
   return total;
   }
   위 코드에서 ...numbers는 함수의 매개변수로 전달되는 모든 값들을 배열로 수집하는 역할을 합니다. 즉, sum(1, 2, 3, 4)처럼 여러 개의 인수를 전달해도 numbers는 [1, 2, 3, 4] 형태의 배열이 되어 반복문을 통해 합산할 수 있습니다.

✅ 나머지 매개변수의 장점
여러 개의 인수를 받을 때 배열로 변환하여 처리 가능
함수 호출 시 개수가 정해지지 않은 인수를 유연하게 다룰 수 있음 2. ...를 사용하지 않은 경우의 문제점

```javascript
function sum(a, b) {
  return a + b;
}
console.log(sum(1, 2, 3, 4)); // 3 (추가된 값 무시됨)
```

sum(1, 2, 3, 4)를 호출해도 a = 1, b = 2까지만 인식하고, 3, 4는 무시됨
이를 해결하기 위해 Rest Parameter를 사용하면 가변적인 수의 인수를 처리할 수 있음
정리
...numbers → 나머지 매개변수(Rest Parameter)를 사용하여 전달된 모든 인수를 배열로 변환
개수가 정해지지 않은 여러 개의 인수를 처리할 때 유용함
가변 길이 매개변수를 처리하는 함수에서 자주 사용됨 🚀

##

```JS
// 객체 매개변수
// function printUserInfo({ name, age, city = "알 수 없음" }) {
//     console.log("\n사용자 정보:");
//     console.log("이름:", name);
//     console.log("나이:", age);
//     console.log("도시:", city);
// }


function printUserInfo(data) {
    const name = data.name;
    const age = data.age;
    const city = data.city
    console.log("\n사용자 정보:");
    console.log("이름:", name);
    console.log("나이:", age);
    console.log("도시:", city);
}

```

# 구조 분해 할당

배열이나 객체의 속성을 해체해 그 값을 개별 변수에 담을 수 있게 하는 표현식

- 변수 선언 코드 간소화
- 기본값 설정 가능
- 변수명 변경 가능능

```JS
const person ={name:"Alice", age:30};
const {name,age}=person;
console.log(name); //"Alice"
console.log(age)=30;
```

## 객체 구조 분해

객체의 속성을 새로운 변수명으로 추출. {}표현. 기본값 설정 가능

```JS
const person = { name: "Alice", age: 30 };

const { name, age, country = "Unknown" } = person;
console.log(name); // "Alice"
console.log(age); // 30
console.log(country); // "Unknown"
```

## 배열 구조 분해 할당

```JS
const numbers = [1, 2, 3, 4, 5];
const [a, b, ,...rest] = numbers; //쉼표로 건너뛰기 가능, 전개 연산자로 나머지 요소를 새 배열로 할당당
console.log(a); // 1
console.log(b); // 2
console.log(rest); // [4, 5]
```

## 매개변수 사용

````JS
### ✨ JavaScript 구조 분해 할당 (Destructuring Assignment)

---

## **1️⃣ 객체 구조 분해**
```js
function printPerson({ name, age }) {
  console.log(`Name: ${name}, Age: ${age}`);
}

const person = { name: "Alice", age: 30, country: "USA" };
printPerson(person);
// 출력: Name: Alice, Age: 30
````

**✔ 설명:**

- 함수의 매개변수에서 객체를 직접 **구조 분해 할당**하여 `name`과 `age`를 추출.

---

## **2️⃣ 배열 구조 분해**

```js
function printCoordinates([x, y]) {
  console.log(`X: ${x}, Y: ${y}`);
}

const point = [10, 20];
printCoordinates(point);
// 출력: X: 10, Y: 20
```

**✔ 설명:**

- 함수의 매개변수에서 배열을 **구조 분해 할당**하여 `x`와 `y`를 추출.

---

## **3️⃣ 중첩 객체 구조 분해**

```js
const person = {
  name: "Alice",
  age: 30,
  address: {
    city: "New York",
    country: "USA",
  },
};

const {
  name,
  address: { city },
} = person;

console.log(name); // "Alice"
console.log(city); // "New York"
```

**✔ 설명:**

- `address` 객체 내부에서 **`city`만 구조 분해**하여 변수에 할당.

---

## **4️⃣ 중첩 배열 구조 분해**

```js
const numbers = [1, [2, 3], 4];

const [a, [b, c], d] = numbers;

console.log(a); // 1
console.log(b); // 2
console.log(c); // 3
console.log(d); // 4
```

**✔ 설명:**

- 배열 안에 **중첩된 배열도 구조 분해 가능** (`[b, c]`).

---

## **✨ 활용 팁**

1. 변수교환

```JS
let a = 1;
let b = 2;
[a, b] = [b, a];
console.log(a); // 2
console.log(b); // 1
```

2. 함수에서 여러 값 반환
3. 필요한 함수나 변수만 선택적으로 가져오기

<div class="end">
——————————————————————————<br/>
본 후기는 [한글과컴퓨터x한국생산성본부x스나이퍼팩토리] 한컴 AI 아카데미 (B-log) 리뷰로 작성 되었습니다.

#한컴AI아카데미 #AI개발자 #AI개발자교육 #한글과컴퓨터 #한국생산성본부 #스나이퍼팩토리 #부트캠프 #AI전문가양성 #개발자교육 #개발자취업

</div>
```
