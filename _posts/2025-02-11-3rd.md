---
layout: post
title: "[스나이퍼팩토리] 한컴AI아카데미 3주차 - JS async, promise"
date: 2025-02-09
categories: [한컴ai]
author: "yujinoh0103"
---

# 비동기처리

자바스크립트 비동기 처리의 중요성
자바스크립트는 싱글 스레드 언어로, 한 번에 하나의 작업만 처리할 수 있습니다. 하지만 웹 애플리케이션에서는 여러 작업을 동시에 처리해야 하는 경우가 많습니다.

왜냐하면 네트워크 요청, 파일 읽기/쓰기, 타이머 등 시간이 오래 걸리는 작업을 동기적으로 처리하면 애플리케이션이 멈추기 때문입니다.

이러한 문제를 해결하기 위해 자바스크립트는 비동기 처리를 지원합니다. 비동기 처리를 통해 여러 작업을 동시에 처리할 수 있습니다.

이번 글에서는 자바스크립트의 비동기 처리 방법인 콜백, 프로미스, 그리고 async/await에 대해 다루어 보겠습니다.

각 방법의 장단점과 사용 예제를 통해 비동기 처리를 효과적으로 사용하는 방법을 알아보겠습니다.

콜백 함수
콜백 함수는 자바스크립트에서 비동기 처리를 구현하는 가장 기본적인 방법입니다. 콜백 함수는 다른 함수의 인자로 전달되어, 특정 작업이 완료된 후 호출됩니다.

왜냐하면 콜백 함수는 비동기 작업이 완료된 후 실행되기 때문에, 비동기 작업의 결과를 처리할 수 있기 때문입니다.

예를 들어, 다음은 콜백 함수를 사용한 비동기 처리 예제입니다:

```JS
function fetchData(callback) {
    setTimeout(() => {
        callback('Data fetched');
    }, 1000);
}

fetchData((data) => {
    console.log(data);
});
```

이 예제에서는 setTimeout 함수를 사용하여 1초 후에 콜백 함수를 호출합니다. 콜백 함수는 'Data fetched'라는 메시지를 출력합니다.

하지만 콜백 함수는 중첩이 깊어질수록 코드가 복잡해지고 가독성이 떨어지는 단점이 있습니다. 이를 콜백 헬이라고 합니다.
프로미스
프로미스는 콜백 함수의 단점을 보완하기 위해 ES6에서 도입된 비동기 처리 방법입니다. <strong>프로미스는 비동기 작업의 성공 또는 실패를 나타내는 객체</strong>입니다.

왜냐하면 프로미스는 비동기 작업의 상태를 관리하고, 체이닝을 통해 여러 비동기 작업을 순차적으로 처리할 수 있기 때문입니다.

예를 들어, 다음은 프로미스를 사용한 비동기 처리 예제입니다:

```JS
function fetchData() {
return new Promise((resolve, reject) => {
setTimeout(() => {
resolve('Data fetched');
}, 1000);
});
}

fetchData().then((data) => {
console.log(data);
}).catch((error) => {
console.error(error);
});
```

이 예제에서는 프로미스를 반환하는 fetchData 함수를 정의하고, then과 catch 메서드를 사용하여 비동기 작업의 결과를 처리합니다.

프로미스를 사용하면 콜백 헬을 피할 수 있고, 코드의 가독성이 향상됩니다. 하지만 여전히 체이닝이 길어질 경우 코드가 복잡해질 수 있습니다.

JavaScript에서 try-catch, then, promise는 비동기 처리 및 예외 처리를 다룰 때 사용되는 주요 개념들입니다. 각 개념에 대해 설명해드릴게요.

Promise:

Promise는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.
비동기 작업이 성공적으로 완료되면 resolve가 호출되고, 실패하면 reject가 호출됩니다.
Promise는 주로 비동기 작업이 완료되었을 때 처리할 후속 작업을 등록할 때 사용됩니다.
javascript
복사
편집
let promise = new Promise((resolve, reject) => {
let success = true; // 예시: 작업 성공 여부
if (success) {
resolve("작업 성공!");
} else {
reject("작업 실패!");
}
});
then:

then은 Promise가 처리된 후 후속 작업을 지정하는 메서드입니다.
then은 resolve가 호출되었을 때 실행되는 콜백 함수를 받습니다. 비동기 작업이 성공적으로 완료되면 then의 첫 번째 콜백이 실행되고, 실패하면 두 번째 콜백이 실행됩니다.
javascript
복사
편집
promise
.then((result) => {
console.log(result); // '작업 성공!' 출력
})
.catch((error) => {
console.log(error); // '작업 실패!' 출력
});
catch는 Promise가 실패할 때 호출됩니다.
종합적으로:

try-catch는 동기적 예외 처리를 위해 사용되고,
Promise는 비동기 작업의 결과를 다루기 위해 사용되며,
then은 비동기 작업이 성공했을 때 후속 처리를 위해 사용됩니다.
비동기 작업을 할 때 Promise와 then을 조합하고, 예외를 처리할 때 try-catch를 사용하는 것이 일반적인 방식입니다.
JavaScript에서 try-catch, then, promise는 비동기 처리 및 예외 처리를 다룰 때 사용되는 주요 개념들입니다. 각 개념에 대해 설명해드릴게요.

Promise:

Promise는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다.
비동기 작업이 성공적으로 완료되면 resolve가 호출되고, 실패하면 reject가 호출됩니다.
Promise는 주로 비동기 작업이 완료되었을 때 처리할 후속 작업을 등록할 때 사용됩니다.
javascript
복사
편집
let promise = new Promise((resolve, reject) => {
let success = true; // 예시: 작업 성공 여부
if (success) {
resolve("작업 성공!");
} else {
reject("작업 실패!");
}
});
then:

then은 Promise가 처리된 후 후속 작업을 지정하는 메서드입니다.
then은 resolve가 호출되었을 때 실행되는 콜백 함수를 받습니다. 비동기 작업이 성공적으로 완료되면 then의 첫 번째 콜백이 실행되고, 실패하면 두 번째 콜백이 실행됩니다.
javascript
복사
편집
promise
.then((result) => {
console.log(result); // '작업 성공!' 출력
})
.catch((error) => {
console.log(error); // '작업 실패!' 출력
});
catch는 Promise가 실패할 때 호출됩니다.
종합적으로:

try-catch는 동기적 예외 처리를 위해 사용되고,
Promise는 비동기 작업의 결과를 다루기 위해 사용되며,
then은 비동기 작업이 성공했을 때 후속 처리를 위해 사용됩니다.
비동기 작업을 할 때 Promise와 then을 조합하고, 예외를 처리할 때 try-catch를 사용하는 것이 일반적인 방식입니다.

```JS
let promise = new Promise((resolve, reject) => {
    console.log("Promise 실행 시작...");

    // 2초 후에 성공 또는 실패
    setTimeout(() => {
        let random = Math.random();
        if (random > 0.5) {
            resolve("성공!");  // 성공 시
        } else {
            reject("실패...");  // 실패 시
        }
    }, 2000);
});

// Promise 사용
console.log("Promise 처리 시작");

promise
    .then((result) => {
        console.log("Promise 성공:", result);
    })
    .catch((error) => {
        console.log("Promise 실패:", error);
    });

//Promise 체이닝
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

console.log("\nPromise 체이닝 시작");

delay(1000)
    .then(() => {
        console.log("1초 지남");
        return delay(1000);
    })
    .then(() => {
        console.log("2초 지남");
        return delay(1000);
    })
    .then(() => {
        console.log("3초 지남");
    });

// async/await 사용
async function runSequence() {
    console.log("\nasync/await 시작");

    try {
        await delay(1000);
        console.log("1초 대기 완료");

        await delay(1000);
        console.log("2초 대기 완료");

        await delay(1000);
        console.log("3초 대기 완료");
    } catch (error) {
        console.log("에러 발생:", error);
    }
}

runSequence();
```

함수도 JS에서는 객체다 !

### async/await

async/await는 프로미스를 더욱 간결하고 직관적으로 사용할 수 있게 해주는 ES8의 비동기 처리 방법입니다. async 함수는 항상 프로미스를 반환하며, await 키워드는 프로미스가 해결될 때까지 기다립니다.

왜냐하면 async/await는 비동기 코드를 동기 코드처럼 작성할 수 있게 해주기 때문입니다. 이를 통해 코드의 가독성과 유지보수성이 크게 향상됩니다.

예를 들어, 다음은 async/await를 사용한 비동기 처리 예제입니다:

```JS
async function fetchData() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data fetched');
        }, 1000);
    });
}

async function main() {
    try {
        const data = await fetchData();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}

main();

```

이 예제에서는 async 함수인 fetchData와 main을 정의하고, await 키워드를 사용하여 비동기 작업의 결과를 기다립니다.

async/await를 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어, 코드의 가독성과 유지보수성이 크게 향상됩니다.

let promise = new Promise((resolve, reject) => {
console.log("Promise 실행 시작...");

    // 2초 후에 성공 또는 실패
    setTimeout(() => {
        let random = Math.random();
        if (random > 0.5) {
            resolve("성공!");  // 성공 시
        } else {
            reject("실패...");  // 실패 시
        }
    }, 2000);

});

// Promise 사용
console.log("Promise 처리 시작");

promise
.then((result) => {
console.log("Promise 성공:", result);
})
.catch((error) => {
console.log("Promise 실패:", error);
});

// Promise 체이닝
function delay(ms) {
return new Promise(resolve => setTimeout(resolve, ms));
}

console.log("\nPromise 체이닝 시작");

delay(1000)
.then(() => {
console.log("1초 지남");
return delay(1000);
})
.then(() => {
console.log("2초 지남");
return delay(1000);
})
.then(() => {
console.log("3초 지남");
});

// async/await 사용
async function runSequence() {
console.log("\nasync/await 시작");

    try {
        await delay(1000);
        console.log("1초 대기 완료");

        await delay(1000);
        console.log("2초 대기 완료");

        await delay(1000);
        console.log("3초 대기 완료");
    } catch (error) {
        console.log("에러 발생:", error);
    }

}

runSequence();

이 코드에서 사용되는 Promise와 callback에 대해 좀 더 자세히 설명해드릴게요!

1. Promise의 기본 구조
   Promise는 비동기 작업의 결과를 다루는 객체입니다. new Promise((resolve, reject) => { ... })로 생성할 수 있습니다. 이 Promise 생성자 함수는 두 개의 인자를 받습니다:

resolve: 작업이 성공했을 때 호출되는 함수입니다.
reject: 작업이 실패했을 때 호출되는 함수입니다.
이 두 인자는 Promise가 비동기 작업을 처리하는 동안, 각각 성공과 실패를 처리하는 역할을 합니다.

예를 들어, 코드에서:

javascript
복사
편집
let promise = new Promise((resolve, reject) => {
console.log("Promise 실행 시작...");

    setTimeout(() => {
        let random = Math.random();
        if (random > 0.5) {
            resolve("성공!");  // 성공 시
        } else {
            reject("실패...");  // 실패 시
        }
    }, 2000);

});
여기서 resolve는 작업이 성공했을 때 호출되고, reject는 실패했을 때 호출됩니다. 이 함수들은 실제 비동기 작업을 다루는 코드 내에서 호출되어, Promise가 처리한 결과를 반환합니다.

2. then과 catch
   Promise 객체는 .then()과 .catch() 메서드를 사용하여 결과를 처리합니다.

then: resolve가 호출될 때 실행되는 코드 블록을 설정합니다.
catch: reject가 호출될 때 실행되는 코드 블록을 설정합니다.
즉, promise 객체가 성공하면 then이, 실패하면 catch가 호출됩니다.

javascript
복사
편집
promise
.then((result) => {
console.log("Promise 성공:", result);
})
.catch((error) => {
console.log("Promise 실패:", error);
});
여기서 result는 resolve가 전달한 값이고, error는 reject가 전달한 값입니다.

3. callback에서 인자 두 개의 의미
   Promise의 생성자에서 사용되는 콜백 함수 (resolve, reject)에서 두 인자 resolve와 reject는 각각 성공 시와 실패 시 결과를 처리하는 함수입니다.

resolve는 작업이 성공하면 호출하고, 성공 결과를 전달합니다.
reject는 작업이 실패하면 호출하고, 실패 원인을 전달합니다. 4. Promise 체이닝과 async/await
Promise 체이닝: 여러 개의 then을 연속적으로 호출하는 방식입니다. 각 then은 앞서 실행된 Promise가 완료된 후 실행됩니다.

async/await: Promise를 더 간결하게 다루기 위해 사용하는 문법입니다. await는 Promise가 완료될 때까지 기다린 후 결과를 반환하며, async는 await를 사용할 수 있게 해주는 함수 선언입니다.

전체 흐름
**Promise**는 비동기 작업의 결과를 성공/실패로 나누어 처리하고, then과 catch를 통해 결과를 다룹니다.
**resolve와 reject**는 각각 성공과 실패를 처리하는 함수입니다.
쉽게 말하면, Promise는 비동기 작업을 추적하고, resolve나 reject를 통해 그 상태를 처리하는 구조입니다.

callback(null, "Data")는 콜백 함수를 호출하는 방식으로, 비동기 함수에서 작업을 완료한 후 결과를 호출하는 방법입니다. 여기서 callback 함수는 fetchData 함수의 인자로 전달됩니다.

1. 콜백 함수와 callback(null, "Data")
   콜백 함수는 주어진 작업을 완료한 후, 그 결과를 다음 함수에 전달하기 위해 사용되는 함수입니다. 비동기 작업에서 callback을 사용하여 결과를 처리하는 일반적인 패턴입니다.

javascript
복사
편집
function fetchData(callback) {
setTimeout(() => {
callback(null, "Data");
}, 1000);
}
위 코드에서 callback(null, "Data")는 콜백 함수를 호출하는 구문입니다:

첫 번째 인자 null: 작업이 정상적으로 수행되었음을 의미합니다. 만약 에러가 발생하면 여기서 error 객체를 전달할 수 있습니다.
두 번째 인자 "Data": 비동기 작업에서 얻은 데이터나 결과입니다. 이 예제에서는 "Data"라는 문자열이 전달됩니다.
즉, callback을 호출하면서 두 가지 값을 전달하는데:

에러 객체 (null은 에러가 없음을 나타냄)
결과값 ("Data"는 작업 결과) 2. fetchData 호출 및 callback 처리
fetchData 함수는 비동기적으로 데이터를 처리하고, 완료 후 callback을 호출하여 결과를 전달합니다. 이때 callback은 아래처럼 정의되어 있습니다:

javascript
복사
편집
fetchData((error, data) => {
if (error) {
console.error(error); // 에러가 있으면 에러 출력
} else {
console.log(data); // 성공하면 데이터를 출력
}
});
여기서 callback 함수는 두 개의 매개변수를 받습니다:

error: 첫 번째 매개변수는 에러 객체로, 만약 비동기 작업 중 에러가 발생했다면 해당 에러 정보를 담습니다. 작업이 성공했다면 null을 넘깁니다.
data: 두 번째 매개변수는 결과 데이터로, 작업이 성공적으로 완료되었을 때 해당 결과값이 전달됩니다. 3. 실행 순서
fetchData 함수가 호출됩니다.
setTimeout이 1초 후에 실행되며, callback(null, "Data")가 호출됩니다.
callback 함수는 null과 "Data"를 전달받고, 에러가 없으므로 "Data"를 출력합니다.
결국, 이 코드는 1초 후에 "Data"를 출력하는 동작을 수행합니다.
